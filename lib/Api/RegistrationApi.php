<?php
/**
 * RegistrationApi
 * PHP version 5
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Rustici Engine API
 *
 * Rustici Engine API
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.39
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace RusticiSoftware\Engine\V2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use RusticiSoftware\Engine\V2\ApiException;
use RusticiSoftware\Engine\V2\Configuration;
use RusticiSoftware\Engine\V2\HeaderSelector;
use RusticiSoftware\Engine\V2\ObjectSerializer;

/**
 * RegistrationApi Class Doc Comment
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RegistrationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation abandonRegistrationSessions
     *
     * Abandon all sessions for `registrationId`. Currently only cmi5 session abandon is supported. For cmi5, section 9.3.6 of the specification allows for an activity to indicate an abnormal termination by a learner's action or due to a system failure. This endpoint thus allows for an activity to mark the session belonging to the specified registration as abandoned.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function abandonRegistrationSessions($engine_tenant_name, $registration_id)
    {
        $this->abandonRegistrationSessionsWithHttpInfo($engine_tenant_name, $registration_id);
    }

    /**
     * Operation abandonRegistrationSessionsWithHttpInfo
     *
     * Abandon all sessions for `registrationId`. Currently only cmi5 session abandon is supported. For cmi5, section 9.3.6 of the specification allows for an activity to indicate an abnormal termination by a learner's action or due to a system failure. This endpoint thus allows for an activity to mark the session belonging to the specified registration as abandoned.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function abandonRegistrationSessionsWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->abandonRegistrationSessionsRequest($engine_tenant_name, $registration_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation abandonRegistrationSessionsAsync
     *
     * Abandon all sessions for `registrationId`. Currently only cmi5 session abandon is supported. For cmi5, section 9.3.6 of the specification allows for an activity to indicate an abnormal termination by a learner's action or due to a system failure. This endpoint thus allows for an activity to mark the session belonging to the specified registration as abandoned.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function abandonRegistrationSessionsAsync($engine_tenant_name, $registration_id)
    {
        return $this->abandonRegistrationSessionsAsyncWithHttpInfo($engine_tenant_name, $registration_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation abandonRegistrationSessionsAsyncWithHttpInfo
     *
     * Abandon all sessions for `registrationId`. Currently only cmi5 session abandon is supported. For cmi5, section 9.3.6 of the specification allows for an activity to indicate an abnormal termination by a learner's action or due to a system failure. This endpoint thus allows for an activity to mark the session belonging to the specified registration as abandoned.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function abandonRegistrationSessionsAsyncWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->abandonRegistrationSessionsRequest($engine_tenant_name, $registration_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'abandonRegistrationSessions'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function abandonRegistrationSessionsRequest($engine_tenant_name, $registration_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling abandonRegistrationSessions'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling abandonRegistrationSessions'
            );
        }

        $resourcePath = '/registrations/{registrationId}/abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildRegistrationLaunchLink
     *
     * Returns the link to use to launch this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema
     */
    public function buildRegistrationLaunchLink($engine_tenant_name, $registration_id, $launch_link_request)
    {
        list($response) = $this->buildRegistrationLaunchLinkWithHttpInfo($engine_tenant_name, $registration_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildRegistrationLaunchLinkWithHttpInfo
     *
     * Returns the link to use to launch this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildRegistrationLaunchLinkWithHttpInfo($engine_tenant_name, $registration_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildRegistrationLaunchLinkRequest($engine_tenant_name, $registration_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildRegistrationLaunchLinkAsync
     *
     * Returns the link to use to launch this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildRegistrationLaunchLinkAsync($engine_tenant_name, $registration_id, $launch_link_request)
    {
        return $this->buildRegistrationLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $registration_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildRegistrationLaunchLinkAsyncWithHttpInfo
     *
     * Returns the link to use to launch this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildRegistrationLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $registration_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildRegistrationLaunchLinkRequest($engine_tenant_name, $registration_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildRegistrationLaunchLink'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildRegistrationLaunchLinkRequest($engine_tenant_name, $registration_id, $launch_link_request)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling buildRegistrationLaunchLink'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling buildRegistrationLaunchLink'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildRegistrationLaunchLink'
            );
        }

        $resourcePath = '/registrations/{registrationId}/launchLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($launch_link_request)) {
            $_tempBody = $launch_link_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNewRegistrationInstance
     *
     * Create a new instance for this registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createNewRegistrationInstance($engine_tenant_name, $registration_id)
    {
        $this->createNewRegistrationInstanceWithHttpInfo($engine_tenant_name, $registration_id);
    }

    /**
     * Operation createNewRegistrationInstanceWithHttpInfo
     *
     * Create a new instance for this registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNewRegistrationInstanceWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->createNewRegistrationInstanceRequest($engine_tenant_name, $registration_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNewRegistrationInstanceAsync
     *
     * Create a new instance for this registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNewRegistrationInstanceAsync($engine_tenant_name, $registration_id)
    {
        return $this->createNewRegistrationInstanceAsyncWithHttpInfo($engine_tenant_name, $registration_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNewRegistrationInstanceAsyncWithHttpInfo
     *
     * Create a new instance for this registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNewRegistrationInstanceAsyncWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->createNewRegistrationInstanceRequest($engine_tenant_name, $registration_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNewRegistrationInstance'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNewRegistrationInstanceRequest($engine_tenant_name, $registration_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling createNewRegistrationInstance'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling createNewRegistrationInstance'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRegistration
     *
     * Create a registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationSchema $registration registration (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createRegistration($engine_tenant_name, $registration, $course_version = null)
    {
        $this->createRegistrationWithHttpInfo($engine_tenant_name, $registration, $course_version);
    }

    /**
     * Operation createRegistrationWithHttpInfo
     *
     * Create a registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationSchema $registration (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRegistrationWithHttpInfo($engine_tenant_name, $registration, $course_version = null)
    {
        $returnType = '';
        $request = $this->createRegistrationRequest($engine_tenant_name, $registration, $course_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRegistrationAsync
     *
     * Create a registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationSchema $registration (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRegistrationAsync($engine_tenant_name, $registration, $course_version = null)
    {
        return $this->createRegistrationAsyncWithHttpInfo($engine_tenant_name, $registration, $course_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRegistrationAsyncWithHttpInfo
     *
     * Create a registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationSchema $registration (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRegistrationAsyncWithHttpInfo($engine_tenant_name, $registration, $course_version = null)
    {
        $returnType = '';
        $request = $this->createRegistrationRequest($engine_tenant_name, $registration, $course_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRegistration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationSchema $registration (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRegistrationRequest($engine_tenant_name, $registration, $course_version = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling createRegistration'
            );
        }
        // verify the required parameter 'registration' is set
        if ($registration === null || (is_array($registration) && count($registration) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration when calling createRegistration'
            );
        }

        $resourcePath = '/registrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_version !== null) {
            $queryParams['courseVersion'] = ObjectSerializer::toQueryValue($course_version);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }


        // body params
        $_tempBody = null;
        if (isset($registration)) {
            $_tempBody = $registration;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRegistrationWithLaunchLink
     *
     * Creates a registration and returns the link to use to launch it
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationWithLaunchLinkSchema $create_request create_request (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema
     */
    public function createRegistrationWithLaunchLink($engine_tenant_name, $create_request, $course_version = null)
    {
        list($response) = $this->createRegistrationWithLaunchLinkWithHttpInfo($engine_tenant_name, $create_request, $course_version);
        return $response;
    }

    /**
     * Operation createRegistrationWithLaunchLinkWithHttpInfo
     *
     * Creates a registration and returns the link to use to launch it
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationWithLaunchLinkSchema $create_request (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRegistrationWithLaunchLinkWithHttpInfo($engine_tenant_name, $create_request, $course_version = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->createRegistrationWithLaunchLinkRequest($engine_tenant_name, $create_request, $course_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRegistrationWithLaunchLinkAsync
     *
     * Creates a registration and returns the link to use to launch it
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationWithLaunchLinkSchema $create_request (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRegistrationWithLaunchLinkAsync($engine_tenant_name, $create_request, $course_version = null)
    {
        return $this->createRegistrationWithLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $create_request, $course_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRegistrationWithLaunchLinkAsyncWithHttpInfo
     *
     * Creates a registration and returns the link to use to launch it
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationWithLaunchLinkSchema $create_request (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRegistrationWithLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $create_request, $course_version = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->createRegistrationWithLaunchLinkRequest($engine_tenant_name, $create_request, $course_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRegistrationWithLaunchLink'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  \RusticiSoftware\Engine\V2\Model\CreateRegistrationWithLaunchLinkSchema $create_request (required)
     * @param  int $course_version The version of the course you want to create the registration for. Unless you have a reason for using this you probably do not need to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRegistrationWithLaunchLinkRequest($engine_tenant_name, $create_request, $course_version = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling createRegistrationWithLaunchLink'
            );
        }
        // verify the required parameter 'create_request' is set
        if ($create_request === null || (is_array($create_request) && count($create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_request when calling createRegistrationWithLaunchLink'
            );
        }

        $resourcePath = '/registrations/withLaunchLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_version !== null) {
            $queryParams['courseVersion'] = ObjectSerializer::toQueryValue($course_version);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }


        // body params
        $_tempBody = null;
        if (isset($create_request)) {
            $_tempBody = $create_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRegistration
     *
     * Delete `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRegistration($engine_tenant_name, $registration_id)
    {
        $this->deleteRegistrationWithHttpInfo($engine_tenant_name, $registration_id);
    }

    /**
     * Operation deleteRegistrationWithHttpInfo
     *
     * Delete `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRegistrationWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationRequest($engine_tenant_name, $registration_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ResponseErrorSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRegistrationAsync
     *
     * Delete `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationAsync($engine_tenant_name, $registration_id)
    {
        return $this->deleteRegistrationAsyncWithHttpInfo($engine_tenant_name, $registration_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRegistrationAsyncWithHttpInfo
     *
     * Delete `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationAsyncWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationRequest($engine_tenant_name, $registration_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRegistration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRegistrationRequest($engine_tenant_name, $registration_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteRegistration'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling deleteRegistration'
            );
        }

        $resourcePath = '/registrations/{registrationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRegistrationConfigurationSetting
     *
     * Clears the `settingId` value for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRegistrationConfigurationSetting($engine_tenant_name, $registration_id, $setting_id)
    {
        $this->deleteRegistrationConfigurationSettingWithHttpInfo($engine_tenant_name, $registration_id, $setting_id);
    }

    /**
     * Operation deleteRegistrationConfigurationSettingWithHttpInfo
     *
     * Clears the `settingId` value for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRegistrationConfigurationSettingWithHttpInfo($engine_tenant_name, $registration_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationConfigurationSettingRequest($engine_tenant_name, $registration_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRegistrationConfigurationSettingAsync
     *
     * Clears the `settingId` value for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationConfigurationSettingAsync($engine_tenant_name, $registration_id, $setting_id)
    {
        return $this->deleteRegistrationConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $registration_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRegistrationConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the `settingId` value for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $registration_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationConfigurationSettingRequest($engine_tenant_name, $registration_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRegistrationConfigurationSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRegistrationConfigurationSettingRequest($engine_tenant_name, $registration_id, $setting_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteRegistrationConfigurationSetting'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling deleteRegistrationConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteRegistrationConfigurationSetting'
            );
        }

        $resourcePath = '/registrations/{registrationId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRegistrationGlobalData
     *
     * delete global data associated with `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRegistrationGlobalData($engine_tenant_name, $registration_id)
    {
        $this->deleteRegistrationGlobalDataWithHttpInfo($engine_tenant_name, $registration_id);
    }

    /**
     * Operation deleteRegistrationGlobalDataWithHttpInfo
     *
     * delete global data associated with `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRegistrationGlobalDataWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationGlobalDataRequest($engine_tenant_name, $registration_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRegistrationGlobalDataAsync
     *
     * delete global data associated with `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationGlobalDataAsync($engine_tenant_name, $registration_id)
    {
        return $this->deleteRegistrationGlobalDataAsyncWithHttpInfo($engine_tenant_name, $registration_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRegistrationGlobalDataAsyncWithHttpInfo
     *
     * delete global data associated with `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationGlobalDataAsyncWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationGlobalDataRequest($engine_tenant_name, $registration_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRegistrationGlobalData'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRegistrationGlobalDataRequest($engine_tenant_name, $registration_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteRegistrationGlobalData'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling deleteRegistrationGlobalData'
            );
        }

        $resourcePath = '/registrations/{registrationId}/globalData';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRegistrationInstance
     *
     * Delete instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRegistrationInstance($engine_tenant_name, $registration_id, $instance_id)
    {
        $this->deleteRegistrationInstanceWithHttpInfo($engine_tenant_name, $registration_id, $instance_id);
    }

    /**
     * Operation deleteRegistrationInstanceWithHttpInfo
     *
     * Delete instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRegistrationInstanceWithHttpInfo($engine_tenant_name, $registration_id, $instance_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationInstanceRequest($engine_tenant_name, $registration_id, $instance_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRegistrationInstanceAsync
     *
     * Delete instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationInstanceAsync($engine_tenant_name, $registration_id, $instance_id)
    {
        return $this->deleteRegistrationInstanceAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRegistrationInstanceAsyncWithHttpInfo
     *
     * Delete instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationInstanceAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationInstanceRequest($engine_tenant_name, $registration_id, $instance_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRegistrationInstance'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRegistrationInstanceRequest($engine_tenant_name, $registration_id, $instance_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteRegistrationInstance'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling deleteRegistrationInstance'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling deleteRegistrationInstance'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRegistrationInstanceConfigurationSetting
     *
     * Clears the `settingId` value for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRegistrationInstanceConfigurationSetting($engine_tenant_name, $registration_id, $instance_id, $setting_id)
    {
        $this->deleteRegistrationInstanceConfigurationSettingWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $setting_id);
    }

    /**
     * Operation deleteRegistrationInstanceConfigurationSettingWithHttpInfo
     *
     * Clears the `settingId` value for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRegistrationInstanceConfigurationSettingWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationInstanceConfigurationSettingRequest($engine_tenant_name, $registration_id, $instance_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRegistrationInstanceConfigurationSettingAsync
     *
     * Clears the `settingId` value for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationInstanceConfigurationSettingAsync($engine_tenant_name, $registration_id, $instance_id, $setting_id)
    {
        return $this->deleteRegistrationInstanceConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRegistrationInstanceConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the `settingId` value for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationInstanceConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationInstanceConfigurationSettingRequest($engine_tenant_name, $registration_id, $instance_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRegistrationInstanceConfigurationSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRegistrationInstanceConfigurationSettingRequest($engine_tenant_name, $registration_id, $instance_id, $setting_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteRegistrationInstanceConfigurationSetting'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling deleteRegistrationInstanceConfigurationSetting'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling deleteRegistrationInstanceConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteRegistrationInstanceConfigurationSetting'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRegistrationProgress
     *
     * delete registration progress (clear registration)
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRegistrationProgress($engine_tenant_name, $registration_id)
    {
        $this->deleteRegistrationProgressWithHttpInfo($engine_tenant_name, $registration_id);
    }

    /**
     * Operation deleteRegistrationProgressWithHttpInfo
     *
     * delete registration progress (clear registration)
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRegistrationProgressWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationProgressRequest($engine_tenant_name, $registration_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRegistrationProgressAsync
     *
     * delete registration progress (clear registration)
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationProgressAsync($engine_tenant_name, $registration_id)
    {
        return $this->deleteRegistrationProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRegistrationProgressAsyncWithHttpInfo
     *
     * delete registration progress (clear registration)
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRegistrationProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->deleteRegistrationProgressRequest($engine_tenant_name, $registration_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRegistrationProgress'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRegistrationProgressRequest($engine_tenant_name, $registration_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteRegistrationProgress'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling deleteRegistrationProgress'
            );
        }

        $resourcePath = '/registrations/{registrationId}/progress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation finalizeRegistrationInstanceProgress
     *
     * Set registration final progress for instance `instanceId` of `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function finalizeRegistrationInstanceProgress($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id = '')
    {
        $this->finalizeRegistrationInstanceProgressWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id);
    }

    /**
     * Operation finalizeRegistrationInstanceProgressWithHttpInfo
     *
     * Set registration final progress for instance `instanceId` of `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function finalizeRegistrationInstanceProgressWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id = '')
    {
        $returnType = '';
        $request = $this->finalizeRegistrationInstanceProgressRequest($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation finalizeRegistrationInstanceProgressAsync
     *
     * Set registration final progress for instance `instanceId` of `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeRegistrationInstanceProgressAsync($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id = '')
    {
        return $this->finalizeRegistrationInstanceProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation finalizeRegistrationInstanceProgressAsyncWithHttpInfo
     *
     * Set registration final progress for instance `instanceId` of `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeRegistrationInstanceProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id = '')
    {
        $returnType = '';
        $request = $this->finalizeRegistrationInstanceProgressRequest($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'finalizeRegistrationInstanceProgress'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function finalizeRegistrationInstanceProgressRequest($engine_tenant_name, $registration_id, $instance_id, $registration_final_state, $activity_id = '')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling finalizeRegistrationInstanceProgress'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling finalizeRegistrationInstanceProgress'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling finalizeRegistrationInstanceProgress'
            );
        }
        // verify the required parameter 'registration_final_state' is set
        if ($registration_final_state === null || (is_array($registration_final_state) && count($registration_final_state) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_final_state when calling finalizeRegistrationInstanceProgress'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}/finalize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($activity_id !== null) {
            $queryParams['activityId'] = ObjectSerializer::toQueryValue($activity_id);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($registration_final_state)) {
            $_tempBody = $registration_final_state;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation finalizeRegistrationProgress
     *
     * Set registration's or activity's final progress for `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function finalizeRegistrationProgress($engine_tenant_name, $registration_id, $registration_final_state, $activity_id = '')
    {
        $this->finalizeRegistrationProgressWithHttpInfo($engine_tenant_name, $registration_id, $registration_final_state, $activity_id);
    }

    /**
     * Operation finalizeRegistrationProgressWithHttpInfo
     *
     * Set registration's or activity's final progress for `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function finalizeRegistrationProgressWithHttpInfo($engine_tenant_name, $registration_id, $registration_final_state, $activity_id = '')
    {
        $returnType = '';
        $request = $this->finalizeRegistrationProgressRequest($engine_tenant_name, $registration_id, $registration_final_state, $activity_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation finalizeRegistrationProgressAsync
     *
     * Set registration's or activity's final progress for `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeRegistrationProgressAsync($engine_tenant_name, $registration_id, $registration_final_state, $activity_id = '')
    {
        return $this->finalizeRegistrationProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $registration_final_state, $activity_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation finalizeRegistrationProgressAsyncWithHttpInfo
     *
     * Set registration's or activity's final progress for `registrationId`. Registration or activity will be placed in review mode to prevent any more changes to this progress. This endpoint may be used for any learning standard, but in cmi5 it has the meaning of \"waive\" (see section 9.3.7 of the cmi5 specification for details on the Waived statement). In the case of cmi5, this endpoint requires `isCompleted` and `isPassed` to both be set to `true` for the waive operation.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeRegistrationProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $registration_final_state, $activity_id = '')
    {
        $returnType = '';
        $request = $this->finalizeRegistrationProgressRequest($engine_tenant_name, $registration_id, $registration_final_state, $activity_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'finalizeRegistrationProgress'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\FinalizeRegistrationProgressSchema $registration_final_state (required)
     * @param  string $activity_id Empty string indicates the overall course. Otherwise, only the activity (the AU for cmi5) with the specified ID is updated. Updating a single activity is currently only supported in cmi5; for other learning standards, this activity ID must be absent or be an empty string to finalize the progress on the entire course. (optional, default to )
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function finalizeRegistrationProgressRequest($engine_tenant_name, $registration_id, $registration_final_state, $activity_id = '')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling finalizeRegistrationProgress'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling finalizeRegistrationProgress'
            );
        }
        // verify the required parameter 'registration_final_state' is set
        if ($registration_final_state === null || (is_array($registration_final_state) && count($registration_final_state) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_final_state when calling finalizeRegistrationProgress'
            );
        }

        $resourcePath = '/registrations/{registrationId}/finalize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($activity_id !== null) {
            $queryParams['activityId'] = ObjectSerializer::toQueryValue($activity_id);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($registration_final_state)) {
            $_tempBody = $registration_final_state;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistration
     *
     * Does this registration exist?
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getRegistration($engine_tenant_name, $registration_id)
    {
        $this->getRegistrationWithHttpInfo($engine_tenant_name, $registration_id);
    }

    /**
     * Operation getRegistrationWithHttpInfo
     *
     * Does this registration exist?
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->getRegistrationRequest($engine_tenant_name, $registration_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationAsync
     *
     * Does this registration exist?
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationAsync($engine_tenant_name, $registration_id)
    {
        return $this->getRegistrationAsyncWithHttpInfo($engine_tenant_name, $registration_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationAsyncWithHttpInfo
     *
     * Does this registration exist?
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationAsyncWithHttpInfo($engine_tenant_name, $registration_id)
    {
        $returnType = '';
        $request = $this->getRegistrationRequest($engine_tenant_name, $registration_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationRequest($engine_tenant_name, $registration_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistration'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistration'
            );
        }

        $resourcePath = '/registrations/{registrationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'HEAD',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationConfiguration
     *
     * Returns all configuration settings for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SettingListSchema
     */
    public function getRegistrationConfiguration($engine_tenant_name, $registration_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        list($response) = $this->getRegistrationConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);
        return $response;
    }

    /**
     * Operation getRegistrationConfigurationWithHttpInfo
     *
     * Returns all configuration settings for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getRegistrationConfigurationRequest($engine_tenant_name, $registration_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationConfigurationAsync
     *
     * Returns all configuration settings for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationConfigurationAsync($engine_tenant_name, $registration_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        return $this->getRegistrationConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationConfigurationAsyncWithHttpInfo
     *
     * Returns all configuration settings for this registration
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getRegistrationConfigurationRequest($engine_tenant_name, $registration_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationConfigurationRequest($engine_tenant_name, $registration_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationConfiguration'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationConfiguration'
            );
        }

        $resourcePath = '/registrations/{registrationId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }
        // query params
        if ($include_hidden_settings !== null) {
            $queryParams['includeHiddenSettings'] = ObjectSerializer::toQueryValue($include_hidden_settings);
        }
        // query params
        if ($include_secret_settings !== null) {
            $queryParams['includeSecretSettings'] = ObjectSerializer::toQueryValue($include_secret_settings);
        }
        // query params
        if ($process_replacement_tokens !== null) {
            $queryParams['processReplacementTokens'] = ObjectSerializer::toQueryValue($process_replacement_tokens);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationInstanceConfiguration
     *
     * Returns all configuration settings for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SettingListSchema
     */
    public function getRegistrationInstanceConfiguration($engine_tenant_name, $registration_id, $instance_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        list($response) = $this->getRegistrationInstanceConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);
        return $response;
    }

    /**
     * Operation getRegistrationInstanceConfigurationWithHttpInfo
     *
     * Returns all configuration settings for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationInstanceConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getRegistrationInstanceConfigurationRequest($engine_tenant_name, $registration_id, $instance_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationInstanceConfigurationAsync
     *
     * Returns all configuration settings for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceConfigurationAsync($engine_tenant_name, $registration_id, $instance_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        return $this->getRegistrationInstanceConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationInstanceConfigurationAsyncWithHttpInfo
     *
     * Returns all configuration settings for this registration instance
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getRegistrationInstanceConfigurationRequest($engine_tenant_name, $registration_id, $instance_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationInstanceConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationInstanceConfigurationRequest($engine_tenant_name, $registration_id, $instance_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationInstanceConfiguration'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationInstanceConfiguration'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling getRegistrationInstanceConfiguration'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }
        // query params
        if ($include_hidden_settings !== null) {
            $queryParams['includeHiddenSettings'] = ObjectSerializer::toQueryValue($include_hidden_settings);
        }
        // query params
        if ($include_secret_settings !== null) {
            $queryParams['includeSecretSettings'] = ObjectSerializer::toQueryValue($include_secret_settings);
        }
        // query params
        if ($process_replacement_tokens !== null) {
            $queryParams['processReplacementTokens'] = ObjectSerializer::toQueryValue($process_replacement_tokens);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationInstanceLaunchHistory
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema
     */
    public function getRegistrationInstanceLaunchHistory($engine_tenant_name, $registration_id, $instance_id, $include_history_log = 'false')
    {
        list($response) = $this->getRegistrationInstanceLaunchHistoryWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_history_log);
        return $response;
    }

    /**
     * Operation getRegistrationInstanceLaunchHistoryWithHttpInfo
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationInstanceLaunchHistoryWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_history_log = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema';
        $request = $this->getRegistrationInstanceLaunchHistoryRequest($engine_tenant_name, $registration_id, $instance_id, $include_history_log);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationInstanceLaunchHistoryAsync
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceLaunchHistoryAsync($engine_tenant_name, $registration_id, $instance_id, $include_history_log = 'false')
    {
        return $this->getRegistrationInstanceLaunchHistoryAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_history_log)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationInstanceLaunchHistoryAsyncWithHttpInfo
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceLaunchHistoryAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_history_log = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema';
        $request = $this->getRegistrationInstanceLaunchHistoryRequest($engine_tenant_name, $registration_id, $instance_id, $include_history_log);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationInstanceLaunchHistory'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationInstanceLaunchHistoryRequest($engine_tenant_name, $registration_id, $instance_id, $include_history_log = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationInstanceLaunchHistory'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationInstanceLaunchHistory'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling getRegistrationInstanceLaunchHistory'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}/launchHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_history_log !== null) {
            $queryParams['includeHistoryLog'] = ObjectSerializer::toQueryValue($include_history_log);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationInstanceProgress
     *
     * Get registration progress for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\RegistrationSchema
     */
    public function getRegistrationInstanceProgress($engine_tenant_name, $registration_id, $instance_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        list($response) = $this->getRegistrationInstanceProgressWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent);
        return $response;
    }

    /**
     * Operation getRegistrationInstanceProgressWithHttpInfo
     *
     * Get registration progress for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\RegistrationSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationInstanceProgressWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationSchema';
        $request = $this->getRegistrationInstanceProgressRequest($engine_tenant_name, $registration_id, $instance_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\RegistrationSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationInstanceProgressAsync
     *
     * Get registration progress for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceProgressAsync($engine_tenant_name, $registration_id, $instance_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        return $this->getRegistrationInstanceProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationInstanceProgressAsyncWithHttpInfo
     *
     * Get registration progress for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationSchema';
        $request = $this->getRegistrationInstanceProgressRequest($engine_tenant_name, $registration_id, $instance_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationInstanceProgress'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationInstanceProgressRequest($engine_tenant_name, $registration_id, $instance_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationInstanceProgress'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationInstanceProgress'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling getRegistrationInstanceProgress'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_child_results !== null) {
            $queryParams['includeChildResults'] = ObjectSerializer::toQueryValue($include_child_results);
        }
        // query params
        if ($include_interactions_and_objectives !== null) {
            $queryParams['includeInteractionsAndObjectives'] = ObjectSerializer::toQueryValue($include_interactions_and_objectives);
        }
        // query params
        if ($include_runtime !== null) {
            $queryParams['includeRuntime'] = ObjectSerializer::toQueryValue($include_runtime);
        }
        // query params
        if ($create_xapi_registration_id_if_absent !== null) {
            $queryParams['createXapiRegistrationIdIfAbsent'] = ObjectSerializer::toQueryValue($create_xapi_registration_id_if_absent);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationInstanceStatements
     *
     * Get xAPI statements for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\XapiStatementResult
     */
    public function getRegistrationInstanceStatements($engine_tenant_name, $registration_id, $instance_id, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getRegistrationInstanceStatementsWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getRegistrationInstanceStatementsWithHttpInfo
     *
     * Get xAPI statements for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationInstanceStatementsWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getRegistrationInstanceStatementsRequest($engine_tenant_name, $registration_id, $instance_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationInstanceStatementsAsync
     *
     * Get xAPI statements for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceStatementsAsync($engine_tenant_name, $registration_id, $instance_id, $since = null, $until = null, $more = null)
    {
        return $this->getRegistrationInstanceStatementsAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationInstanceStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for instance `instanceId` of `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstanceStatementsAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getRegistrationInstanceStatementsRequest($engine_tenant_name, $registration_id, $instance_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationInstanceStatements'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationInstanceStatementsRequest($engine_tenant_name, $registration_id, $instance_id, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationInstanceStatements'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationInstanceStatements'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling getRegistrationInstanceStatements'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationInstances
     *
     * Get all the instances of this the registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\RegistrationListSchema
     */
    public function getRegistrationInstances($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        list($response) = $this->getRegistrationInstancesWithHttpInfo($engine_tenant_name, $registration_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime);
        return $response;
    }

    /**
     * Operation getRegistrationInstancesWithHttpInfo
     *
     * Get all the instances of this the registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\RegistrationListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationInstancesWithHttpInfo($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationListSchema';
        $request = $this->getRegistrationInstancesRequest($engine_tenant_name, $registration_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\RegistrationListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationInstancesAsync
     *
     * Get all the instances of this the registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstancesAsync($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        return $this->getRegistrationInstancesAsyncWithHttpInfo($engine_tenant_name, $registration_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationInstancesAsyncWithHttpInfo
     *
     * Get all the instances of this the registration specified by the registration ID
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationInstancesAsyncWithHttpInfo($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationListSchema';
        $request = $this->getRegistrationInstancesRequest($engine_tenant_name, $registration_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationInstances'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationInstancesRequest($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationInstances'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationInstances'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // query params
        if ($include_child_results !== null) {
            $queryParams['includeChildResults'] = ObjectSerializer::toQueryValue($include_child_results);
        }
        // query params
        if ($include_interactions_and_objectives !== null) {
            $queryParams['includeInteractionsAndObjectives'] = ObjectSerializer::toQueryValue($include_interactions_and_objectives);
        }
        // query params
        if ($include_runtime !== null) {
            $queryParams['includeRuntime'] = ObjectSerializer::toQueryValue($include_runtime);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationLaunchHistory
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema
     */
    public function getRegistrationLaunchHistory($engine_tenant_name, $registration_id, $include_history_log = 'false')
    {
        list($response) = $this->getRegistrationLaunchHistoryWithHttpInfo($engine_tenant_name, $registration_id, $include_history_log);
        return $response;
    }

    /**
     * Operation getRegistrationLaunchHistoryWithHttpInfo
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationLaunchHistoryWithHttpInfo($engine_tenant_name, $registration_id, $include_history_log = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema';
        $request = $this->getRegistrationLaunchHistoryRequest($engine_tenant_name, $registration_id, $include_history_log);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationLaunchHistoryAsync
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationLaunchHistoryAsync($engine_tenant_name, $registration_id, $include_history_log = 'false')
    {
        return $this->getRegistrationLaunchHistoryAsyncWithHttpInfo($engine_tenant_name, $registration_id, $include_history_log)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationLaunchHistoryAsyncWithHttpInfo
     *
     * Returns history of this registration's launches
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationLaunchHistoryAsyncWithHttpInfo($engine_tenant_name, $registration_id, $include_history_log = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchHistoryListSchema';
        $request = $this->getRegistrationLaunchHistoryRequest($engine_tenant_name, $registration_id, $include_history_log);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationLaunchHistory'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_history_log Whether to include the history log in the launch history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationLaunchHistoryRequest($engine_tenant_name, $registration_id, $include_history_log = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationLaunchHistory'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationLaunchHistory'
            );
        }

        $resourcePath = '/registrations/{registrationId}/launchHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_history_log !== null) {
            $queryParams['includeHistoryLog'] = ObjectSerializer::toQueryValue($include_history_log);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationProgress
     *
     * Get registration progress for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\RegistrationSchema
     */
    public function getRegistrationProgress($engine_tenant_name, $registration_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        list($response) = $this->getRegistrationProgressWithHttpInfo($engine_tenant_name, $registration_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent);
        return $response;
    }

    /**
     * Operation getRegistrationProgressWithHttpInfo
     *
     * Get registration progress for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\RegistrationSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationProgressWithHttpInfo($engine_tenant_name, $registration_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationSchema';
        $request = $this->getRegistrationProgressRequest($engine_tenant_name, $registration_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\RegistrationSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationProgressAsync
     *
     * Get registration progress for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationProgressAsync($engine_tenant_name, $registration_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        return $this->getRegistrationProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationProgressAsyncWithHttpInfo
     *
     * Get registration progress for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationProgressAsyncWithHttpInfo($engine_tenant_name, $registration_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationSchema';
        $request = $this->getRegistrationProgressRequest($engine_tenant_name, $registration_id, $include_child_results, $include_interactions_and_objectives, $include_runtime, $create_xapi_registration_id_if_absent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationProgress'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     * @param  bool $create_xapi_registration_id_if_absent create the xAPI registration ID for this registration if one does not already exist (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationProgressRequest($engine_tenant_name, $registration_id, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false', $create_xapi_registration_id_if_absent = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationProgress'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationProgress'
            );
        }

        $resourcePath = '/registrations/{registrationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_child_results !== null) {
            $queryParams['includeChildResults'] = ObjectSerializer::toQueryValue($include_child_results);
        }
        // query params
        if ($include_interactions_and_objectives !== null) {
            $queryParams['includeInteractionsAndObjectives'] = ObjectSerializer::toQueryValue($include_interactions_and_objectives);
        }
        // query params
        if ($include_runtime !== null) {
            $queryParams['includeRuntime'] = ObjectSerializer::toQueryValue($include_runtime);
        }
        // query params
        if ($create_xapi_registration_id_if_absent !== null) {
            $queryParams['createXapiRegistrationIdIfAbsent'] = ObjectSerializer::toQueryValue($create_xapi_registration_id_if_absent);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrationStatements
     *
     * Get xAPI statements for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\XapiStatementResult
     */
    public function getRegistrationStatements($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getRegistrationStatementsWithHttpInfo($engine_tenant_name, $registration_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getRegistrationStatementsWithHttpInfo
     *
     * Get xAPI statements for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationStatementsWithHttpInfo($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getRegistrationStatementsRequest($engine_tenant_name, $registration_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationStatementsAsync
     *
     * Get xAPI statements for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationStatementsAsync($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null)
    {
        return $this->getRegistrationStatementsAsyncWithHttpInfo($engine_tenant_name, $registration_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for `registrationId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationStatementsAsyncWithHttpInfo($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getRegistrationStatementsRequest($engine_tenant_name, $registration_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrationStatements'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationStatementsRequest($engine_tenant_name, $registration_id, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrationStatements'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling getRegistrationStatements'
            );
        }

        $resourcePath = '/registrations/{registrationId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRegistrations
     *
     * Gets a list of registrations including a summary of the status of each registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id Only registrations for the specified course id will be included. (optional)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\RegistrationListSchema
     */
    public function getRegistrations($engine_tenant_name, $course_id = null, $learner_id = null, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        list($response) = $this->getRegistrationsWithHttpInfo($engine_tenant_name, $course_id, $learner_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime);
        return $response;
    }

    /**
     * Operation getRegistrationsWithHttpInfo
     *
     * Gets a list of registrations including a summary of the status of each registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id Only registrations for the specified course id will be included. (optional)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\RegistrationListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRegistrationsWithHttpInfo($engine_tenant_name, $course_id = null, $learner_id = null, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationListSchema';
        $request = $this->getRegistrationsRequest($engine_tenant_name, $course_id, $learner_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\RegistrationListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRegistrationsAsync
     *
     * Gets a list of registrations including a summary of the status of each registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id Only registrations for the specified course id will be included. (optional)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationsAsync($engine_tenant_name, $course_id = null, $learner_id = null, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        return $this->getRegistrationsAsyncWithHttpInfo($engine_tenant_name, $course_id, $learner_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRegistrationsAsyncWithHttpInfo
     *
     * Gets a list of registrations including a summary of the status of each registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id Only registrations for the specified course id will be included. (optional)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRegistrationsAsyncWithHttpInfo($engine_tenant_name, $course_id = null, $learner_id = null, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\RegistrationListSchema';
        $request = $this->getRegistrationsRequest($engine_tenant_name, $course_id, $learner_id, $since, $until, $more, $include_child_results, $include_interactions_and_objectives, $include_runtime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRegistrations'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id Only registrations for the specified course id will be included. (optional)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  bool $include_child_results Include information about each learning object, not just the top level in the results (optional, default to false)
     * @param  bool $include_interactions_and_objectives Include interactions and objectives in the results (optional, default to false)
     * @param  bool $include_runtime Include runtime details in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRegistrationsRequest($engine_tenant_name, $course_id = null, $learner_id = null, $since = null, $until = null, $more = null, $include_child_results = 'false', $include_interactions_and_objectives = 'false', $include_runtime = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getRegistrations'
            );
        }

        $resourcePath = '/registrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($learner_id !== null) {
            $queryParams['learnerId'] = ObjectSerializer::toQueryValue($learner_id);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // query params
        if ($include_child_results !== null) {
            $queryParams['includeChildResults'] = ObjectSerializer::toQueryValue($include_child_results);
        }
        // query params
        if ($include_interactions_and_objectives !== null) {
            $queryParams['includeInteractionsAndObjectives'] = ObjectSerializer::toQueryValue($include_interactions_and_objectives);
        }
        // query params
        if ($include_runtime !== null) {
            $queryParams['includeRuntime'] = ObjectSerializer::toQueryValue($include_runtime);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ltiBasicOutcomes
     *
     * Endpoint for LTI basic outcomes
     *
     * @param  string $outcomes_request outcomes_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function ltiBasicOutcomes($outcomes_request)
    {
        list($response) = $this->ltiBasicOutcomesWithHttpInfo($outcomes_request);
        return $response;
    }

    /**
     * Operation ltiBasicOutcomesWithHttpInfo
     *
     * Endpoint for LTI basic outcomes
     *
     * @param  string $outcomes_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function ltiBasicOutcomesWithHttpInfo($outcomes_request)
    {
        $returnType = 'string';
        $request = $this->ltiBasicOutcomesRequest($outcomes_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ltiBasicOutcomesAsync
     *
     * Endpoint for LTI basic outcomes
     *
     * @param  string $outcomes_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ltiBasicOutcomesAsync($outcomes_request)
    {
        return $this->ltiBasicOutcomesAsyncWithHttpInfo($outcomes_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ltiBasicOutcomesAsyncWithHttpInfo
     *
     * Endpoint for LTI basic outcomes
     *
     * @param  string $outcomes_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ltiBasicOutcomesAsyncWithHttpInfo($outcomes_request)
    {
        $returnType = 'string';
        $request = $this->ltiBasicOutcomesRequest($outcomes_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ltiBasicOutcomes'
     *
     * @param  string $outcomes_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ltiBasicOutcomesRequest($outcomes_request)
    {
        // verify the required parameter 'outcomes_request' is set
        if ($outcomes_request === null || (is_array($outcomes_request) && count($outcomes_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $outcomes_request when calling ltiBasicOutcomes'
            );
        }

        $resourcePath = '/registrations/ltiBasicOutcomes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($outcomes_request)) {
            $_tempBody = $outcomes_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setRegistrationConfiguration
     *
     * Set configuration settings for this registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setRegistrationConfiguration($engine_tenant_name, $registration_id, $configuration_settings)
    {
        $this->setRegistrationConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $configuration_settings);
    }

    /**
     * Operation setRegistrationConfigurationWithHttpInfo
     *
     * Set configuration settings for this registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRegistrationConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setRegistrationConfigurationRequest($engine_tenant_name, $registration_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setRegistrationConfigurationAsync
     *
     * Set configuration settings for this registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRegistrationConfigurationAsync($engine_tenant_name, $registration_id, $configuration_settings)
    {
        return $this->setRegistrationConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setRegistrationConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for this registration.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRegistrationConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setRegistrationConfigurationRequest($engine_tenant_name, $registration_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setRegistrationConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setRegistrationConfigurationRequest($engine_tenant_name, $registration_id, $configuration_settings)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setRegistrationConfiguration'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling setRegistrationConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setRegistrationConfiguration'
            );
        }

        $resourcePath = '/registrations/{registrationId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setRegistrationInstanceConfiguration
     *
     * Set configuration settings for this registration instance.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setRegistrationInstanceConfiguration($engine_tenant_name, $registration_id, $instance_id, $configuration_settings)
    {
        $this->setRegistrationInstanceConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $configuration_settings);
    }

    /**
     * Operation setRegistrationInstanceConfigurationWithHttpInfo
     *
     * Set configuration settings for this registration instance.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRegistrationInstanceConfigurationWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setRegistrationInstanceConfigurationRequest($engine_tenant_name, $registration_id, $instance_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setRegistrationInstanceConfigurationAsync
     *
     * Set configuration settings for this registration instance.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRegistrationInstanceConfigurationAsync($engine_tenant_name, $registration_id, $instance_id, $configuration_settings)
    {
        return $this->setRegistrationInstanceConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setRegistrationInstanceConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for this registration instance.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRegistrationInstanceConfigurationAsyncWithHttpInfo($engine_tenant_name, $registration_id, $instance_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setRegistrationInstanceConfigurationRequest($engine_tenant_name, $registration_id, $instance_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setRegistrationInstanceConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $registration_id id for this registration (required)
     * @param  int $instance_id the instance of this registration (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setRegistrationInstanceConfigurationRequest($engine_tenant_name, $registration_id, $instance_id, $configuration_settings)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setRegistrationInstanceConfiguration'
            );
        }
        // verify the required parameter 'registration_id' is set
        if ($registration_id === null || (is_array($registration_id) && count($registration_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration_id when calling setRegistrationInstanceConfiguration'
            );
        }
        // verify the required parameter 'instance_id' is set
        if ($instance_id === null || (is_array($instance_id) && count($instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_id when calling setRegistrationInstanceConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setRegistrationInstanceConfiguration'
            );
        }

        $resourcePath = '/registrations/{registrationId}/instances/{instanceId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($registration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'registrationId' . '}',
                ObjectSerializer::toPathValue($registration_id),
                $resourcePath
            );
        }
        // path params
        if ($instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceId' . '}',
                ObjectSerializer::toPathValue($instance_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
