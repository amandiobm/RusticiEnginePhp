<?php
/**
 * CourseApi
 * PHP version 5
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Rustici Engine API
 *
 * Rustici Engine API
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.10
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace RusticiSoftware\Engine\V2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use RusticiSoftware\Engine\V2\ApiException;
use RusticiSoftware\Engine\V2\Configuration;
use RusticiSoftware\Engine\V2\HeaderSelector;
use RusticiSoftware\Engine\V2\ObjectSerializer;

/**
 * CourseApi Class Doc Comment
 *
 * @category Class
 * @package  RusticiSoftware\Engine\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CourseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation buildCoursePreviewLaunchLink
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema
     */
    public function buildCoursePreviewLaunchLink($engine_tenant_name, $course_id, $launch_link_request)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkRequest($engine_tenant_name, $course_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsync
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsync($engine_tenant_name, $course_id, $launch_link_request)
    {
        return $this->buildCoursePreviewLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkAsyncWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkAsyncWithHttpInfo($engine_tenant_name, $course_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkRequest($engine_tenant_name, $course_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLink'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildCoursePreviewLaunchLinkRequest($engine_tenant_name, $course_id, $launch_link_request)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling buildCoursePreviewLaunchLink'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLink'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLink'
            );
        }

        $resourcePath = '/courses/{courseId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($launch_link_request)) {
            $_tempBody = $launch_link_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersion
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema
     */
    public function buildCoursePreviewLaunchLinkWithVersion($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        list($response) = $this->buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request);
        return $response;
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\LaunchLinkSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildCoursePreviewLaunchLinkWithVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($engine_tenant_name, $course_id, $version_id, $launch_link_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsync
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsync($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        return $this->buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo
     *
     * Returns the link to use to preview this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildCoursePreviewLaunchLinkWithVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\LaunchLinkSchema';
        $request = $this->buildCoursePreviewLaunchLinkWithVersionRequest($engine_tenant_name, $course_id, $version_id, $launch_link_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildCoursePreviewLaunchLinkWithVersion'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\LaunchLinkRequestSchema $launch_link_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildCoursePreviewLaunchLinkWithVersionRequest($engine_tenant_name, $course_id, $version_id, $launch_link_request)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }
        // verify the required parameter 'launch_link_request' is set
        if ($launch_link_request === null || (is_array($launch_link_request) && count($launch_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $launch_link_request when calling buildCoursePreviewLaunchLinkWithVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($launch_link_request)) {
            $_tempBody = $launch_link_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFetchAndImportCourseJob
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema
     */
    public function createFetchAndImportCourseJob($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false')
    {
        list($response) = $this->createFetchAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version);
        return $response;
    }

    /**
     * Operation createFetchAndImportCourseJobWithHttpInfo
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFetchAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createFetchAndImportCourseJobRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFetchAndImportCourseJobAsync
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsync($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false')
    {
        return $this->createFetchAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFetchAndImportCourseJobAsyncWithHttpInfo
     *
     * Start a job to fetch and import a course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFetchAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createFetchAndImportCourseJobRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFetchAndImportCourseJob'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportFetchRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFetchAndImportCourseJobRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling createFetchAndImportCourseJob'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createFetchAndImportCourseJob'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling createFetchAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }


        // body params
        $_tempBody = null;
        if (isset($import_request)) {
            $_tempBody = $import_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUploadAndImportCourseJob
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\StringResultSchema
     */
    public function createUploadAndImportCourseJob($engine_tenant_name, $course_id, $may_create_new_version = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        list($response) = $this->createUploadAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $file, $uploaded_content_type);
        return $response;
    }

    /**
     * Operation createUploadAndImportCourseJobWithHttpInfo
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\StringResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUploadAndImportCourseJobWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createUploadAndImportCourseJobRequest($engine_tenant_name, $course_id, $may_create_new_version, $file, $uploaded_content_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\StringResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createUploadAndImportCourseJobAsync
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsync($engine_tenant_name, $course_id, $may_create_new_version = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        return $this->createUploadAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $file, $uploaded_content_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUploadAndImportCourseJobAsyncWithHttpInfo
     *
     * Upload a course and start an import job for it.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadAndImportCourseJobAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\StringResultSchema';
        $request = $this->createUploadAndImportCourseJobRequest($engine_tenant_name, $course_id, $may_create_new_version, $file, $uploaded_content_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUploadAndImportCourseJob'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createUploadAndImportCourseJobRequest($engine_tenant_name, $course_id, $may_create_new_version = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling createUploadAndImportCourseJob'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling createUploadAndImportCourseJob'
            );
        }

        $resourcePath = '/courses/importJobs/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }
        // header params
        if ($uploaded_content_type !== null) {
            $headerParams['uploadedContentType'] = ObjectSerializer::toHeaderValue($uploaded_content_type);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourse
     *
     * Delete `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourse($engine_tenant_name, $course_id)
    {
        $this->deleteCourseWithHttpInfo($engine_tenant_name, $course_id);
    }

    /**
     * Operation deleteCourseWithHttpInfo
     *
     * Delete `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseWithHttpInfo($engine_tenant_name, $course_id)
    {
        $returnType = '';
        $request = $this->deleteCourseRequest($engine_tenant_name, $course_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseAsync
     *
     * Delete `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsync($engine_tenant_name, $course_id)
    {
        return $this->deleteCourseAsyncWithHttpInfo($engine_tenant_name, $course_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseAsyncWithHttpInfo
     *
     * Delete `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseAsyncWithHttpInfo($engine_tenant_name, $course_id)
    {
        $returnType = '';
        $request = $this->deleteCourseRequest($engine_tenant_name, $course_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourse'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseRequest($engine_tenant_name, $course_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourse'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseConfigurationSetting
     *
     * Clears the `settingId` value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseConfigurationSetting($engine_tenant_name, $course_id, $setting_id)
    {
        $this->deleteCourseConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $setting_id);
    }

    /**
     * Operation deleteCourseConfigurationSettingWithHttpInfo
     *
     * Clears the `settingId` value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseConfigurationSettingAsync
     *
     * Clears the `settingId` value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsync($engine_tenant_name, $course_id, $setting_id)
    {
        return $this->deleteCourseConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the `settingId` value for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseConfigurationSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseConfigurationSettingRequest($engine_tenant_name, $course_id, $setting_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseConfigurationSetting'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersion
     *
     * Delete version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersion($engine_tenant_name, $course_id, $version_id)
    {
        $this->deleteCourseVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id);
    }

    /**
     * Operation deleteCourseVersionWithHttpInfo
     *
     * Delete version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionWithHttpInfo($engine_tenant_name, $course_id, $version_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionRequest($engine_tenant_name, $course_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionAsync
     *
     * Delete version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsync($engine_tenant_name, $course_id, $version_id)
    {
        return $this->deleteCourseVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionAsyncWithHttpInfo
     *
     * Delete version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionRequest($engine_tenant_name, $course_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersion'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseVersionRequest($engine_tenant_name, $course_id, $version_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseVersion'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersion'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersion'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCourseVersionConfigurationSetting
     *
     * Clears the `settingId` value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCourseVersionConfigurationSetting($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        $this->deleteCourseVersionConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id);
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingWithHttpInfo
     *
     * Clears the `settingId` value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCourseVersionConfigurationSettingWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionConfigurationSettingRequest($engine_tenant_name, $course_id, $version_id, $setting_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsync
     *
     * Clears the `settingId` value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsync($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        return $this->deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCourseVersionConfigurationSettingAsyncWithHttpInfo
     *
     * Clears the `settingId` value for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCourseVersionConfigurationSettingAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        $returnType = '';
        $request = $this->deleteCourseVersionConfigurationSettingRequest($engine_tenant_name, $course_id, $version_id, $setting_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCourseVersionConfigurationSetting'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $setting_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCourseVersionConfigurationSettingRequest($engine_tenant_name, $course_id, $version_id, $setting_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteCourseVersionConfigurationSetting'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling deleteCourseVersionConfigurationSetting'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration/{settingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'settingId' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourse
     *
     * Get information about `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseSchema
     */
    public function getCourse($engine_tenant_name, $course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseWithHttpInfo
     *
     * Get information about `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
        $request = $this->getCourseRequest($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseAsync
     *
     * Get information about `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsync($engine_tenant_name, $course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseAsyncWithHttpInfo
     *
     * Get information about `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
        $request = $this->getCourseRequest($engine_tenant_name, $course_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourse'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseRequest($engine_tenant_name, $course_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourse'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourse'
            );
        }

        $resourcePath = '/courses/{courseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseConfiguration
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SettingListSchema
     */
    public function getCourseConfiguration($engine_tenant_name, $course_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        list($response) = $this->getCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);
        return $response;
    }

    /**
     * Operation getCourseConfigurationWithHttpInfo
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getCourseConfigurationRequest($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseConfigurationAsync
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsync($engine_tenant_name, $course_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        return $this->getCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseConfigurationAsyncWithHttpInfo
     *
     * Returns all configuration settings for this course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getCourseConfigurationRequest($engine_tenant_name, $course_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseConfigurationRequest($engine_tenant_name, $course_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }
        // query params
        if ($include_hidden_settings !== null) {
            $queryParams['includeHiddenSettings'] = ObjectSerializer::toQueryValue($include_hidden_settings);
        }
        // query params
        if ($include_secret_settings !== null) {
            $queryParams['includeSecretSettings'] = ObjectSerializer::toQueryValue($include_secret_settings);
        }
        // query params
        if ($process_replacement_tokens !== null) {
            $queryParams['processReplacementTokens'] = ObjectSerializer::toQueryValue($process_replacement_tokens);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseStatements
     *
     * Get xAPI statements for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\XapiStatementResult
     */
    public function getCourseStatements($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseStatementsWithHttpInfo($engine_tenant_name, $course_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseStatementsWithHttpInfo
     *
     * Get xAPI statements for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseStatementsWithHttpInfo($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getCourseStatementsRequest($engine_tenant_name, $course_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseStatementsAsync
     *
     * Get xAPI statements for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsync($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getCourseStatementsRequest($engine_tenant_name, $course_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseStatements'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseStatementsRequest($engine_tenant_name, $course_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseStatements'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($learner_id !== null) {
            $queryParams['learnerId'] = ObjectSerializer::toQueryValue($learner_id);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionConfiguration
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\SettingListSchema
     */
    public function getCourseVersionConfiguration($engine_tenant_name, $course_id, $version_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        list($response) = $this->getCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);
        return $response;
    }

    /**
     * Operation getCourseVersionConfigurationWithHttpInfo
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\SettingListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\SettingListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionConfigurationAsync
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsync($engine_tenant_name, $course_id, $version_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        return $this->getCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Returns all configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\SettingListSchema';
        $request = $this->getCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $include_metadata, $include_hidden_settings, $include_secret_settings, $process_replacement_tokens);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_metadata (optional, default to false)
     * @param  bool $include_hidden_settings Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. (optional, default to false)
     * @param  bool $include_secret_settings Should settings that are stored encrypted (type &#39;secretString&#39;) be included. Note: if included, the decrypted value will be returned. (optional, default to false)
     * @param  bool $process_replacement_tokens Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements) (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $include_metadata = 'false', $include_hidden_settings = 'false', $include_secret_settings = 'false', $process_replacement_tokens = 'true')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_metadata !== null) {
            $queryParams['includeMetadata'] = ObjectSerializer::toQueryValue($include_metadata);
        }
        // query params
        if ($include_hidden_settings !== null) {
            $queryParams['includeHiddenSettings'] = ObjectSerializer::toQueryValue($include_hidden_settings);
        }
        // query params
        if ($include_secret_settings !== null) {
            $queryParams['includeSecretSettings'] = ObjectSerializer::toQueryValue($include_secret_settings);
        }
        // query params
        if ($process_replacement_tokens !== null) {
            $queryParams['processReplacementTokens'] = ObjectSerializer::toQueryValue($process_replacement_tokens);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionInfo
     *
     * Get version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseSchema
     */
    public function getCourseVersionInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseVersionInfoWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionInfoWithHttpInfo
     *
     * Get version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionInfoWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
        $request = $this->getCourseVersionInfoRequest($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionInfoAsync
     *
     * Get version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsync($engine_tenant_name, $course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseVersionInfoAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionInfoAsyncWithHttpInfo
     *
     * Get version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionInfoAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseSchema';
        $request = $this->getCourseVersionInfoRequest($engine_tenant_name, $course_id, $version_id, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionInfo'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionInfoRequest($engine_tenant_name, $course_id, $version_id, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionInfo'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionInfo'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionInfo'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersionStatements
     *
     * Get xAPI statements for version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\XapiStatementResult
     */
    public function getCourseVersionStatements($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        list($response) = $this->getCourseVersionStatementsWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more);
        return $response;
    }

    /**
     * Operation getCourseVersionStatementsWithHttpInfo
     *
     * Get xAPI statements for version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\XapiStatementResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionStatementsWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getCourseVersionStatementsRequest($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\XapiStatementResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionStatementsAsync
     *
     * Get xAPI statements for version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsync($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        return $this->getCourseVersionStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionStatementsAsyncWithHttpInfo
     *
     * Get xAPI statements for version `versionId` of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionStatementsAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\XapiStatementResult';
        $request = $this->getCourseVersionStatementsRequest($engine_tenant_name, $course_id, $version_id, $learner_id, $since, $until, $more);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersionStatements'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  string $learner_id Only entries for the specified learner id will be included. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionStatementsRequest($engine_tenant_name, $course_id, $version_id, $learner_id = null, $since = null, $until = null, $more = null)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersionStatements'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersionStatements'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getCourseVersionStatements'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/xAPIStatements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($learner_id !== null) {
            $queryParams['learnerId'] = ObjectSerializer::toQueryValue($learner_id);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourseVersions
     *
     * Get all versions of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema
     */
    public function getCourseVersions($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCourseVersionsWithHttpInfo($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCourseVersionsWithHttpInfo
     *
     * Get all versions of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCourseVersionsWithHttpInfo($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema';
        $request = $this->getCourseVersionsRequest($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCourseVersionsAsync
     *
     * Get all versions of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsync($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCourseVersionsAsyncWithHttpInfo($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCourseVersionsAsyncWithHttpInfo
     *
     * Get all versions of `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCourseVersionsAsyncWithHttpInfo($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListNonPagedSchema';
        $request = $this->getCourseVersionsRequest($engine_tenant_name, $course_id, $since, $until, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourseVersions'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCourseVersionsRequest($engine_tenant_name, $course_id, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourseVersions'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling getCourseVersions'
            );
        }

        $resourcePath = '/courses/{courseId}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCourses
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\CourseListSchema
     */
    public function getCourses($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        list($response) = $this->getCoursesWithHttpInfo($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata);
        return $response;
    }

    /**
     * Operation getCoursesWithHttpInfo
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\CourseListSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCoursesWithHttpInfo($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListSchema';
        $request = $this->getCoursesRequest($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\CourseListSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCoursesAsync
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsync($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        return $this->getCoursesAsyncWithHttpInfo($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCoursesAsyncWithHttpInfo
     *
     * Get a list of all courses for the specified tenant
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCoursesAsyncWithHttpInfo($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\CourseListSchema';
        $request = $this->getCoursesRequest($engine_tenant_name, $more, $since, $until, $include_registration_count, $include_course_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCourses'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $more Value for this parameter will be provided in the &#39;more&#39; property of lists, where needed. An opaque value, construction and parsing may change without notice. (optional)
     * @param  \DateTime $since Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  \DateTime $until Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used. (optional)
     * @param  bool $include_registration_count Include the registration count in the results (optional, default to false)
     * @param  bool $include_course_metadata Include course metadata in the results (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCoursesRequest($engine_tenant_name, $more = null, $since = null, $until = null, $include_registration_count = 'false', $include_course_metadata = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getCourses'
            );
        }

        $resourcePath = '/courses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($more !== null) {
            $queryParams['more'] = ObjectSerializer::toQueryValue($more);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = ObjectSerializer::toQueryValue($until);
        }
        // query params
        if ($include_registration_count !== null) {
            $queryParams['includeRegistrationCount'] = ObjectSerializer::toQueryValue($include_registration_count);
        }
        // query params
        if ($include_course_metadata !== null) {
            $queryParams['includeCourseMetadata'] = ObjectSerializer::toQueryValue($include_course_metadata);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImportJobStatus
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\ImportJobResultSchema
     */
    public function getImportJobStatus($engine_tenant_name, $import_job_id)
    {
        list($response) = $this->getImportJobStatusWithHttpInfo($engine_tenant_name, $import_job_id);
        return $response;
    }

    /**
     * Operation getImportJobStatusWithHttpInfo
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\ImportJobResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImportJobStatusWithHttpInfo($engine_tenant_name, $import_job_id)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema';
        $request = $this->getImportJobStatusRequest($engine_tenant_name, $import_job_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ResponseErrorSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImportJobStatusAsync
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsync($engine_tenant_name, $import_job_id)
    {
        return $this->getImportJobStatusAsyncWithHttpInfo($engine_tenant_name, $import_job_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImportJobStatusAsyncWithHttpInfo
     *
     * Check the status of an import job.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImportJobStatusAsyncWithHttpInfo($engine_tenant_name, $import_job_id)
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportJobResultSchema';
        $request = $this->getImportJobStatusRequest($engine_tenant_name, $import_job_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImportJobStatus'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $import_job_id Id received when the import job was submitted to the importJobs resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImportJobStatusRequest($engine_tenant_name, $import_job_id)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling getImportJobStatus'
            );
        }
        // verify the required parameter 'import_job_id' is set
        if ($import_job_id === null || (is_array($import_job_id) && count($import_job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_job_id when calling getImportJobStatus'
            );
        }

        $resourcePath = '/courses/importJobs/{importJobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($import_job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'importJobId' . '}',
                ObjectSerializer::toPathValue($import_job_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importCourseWithoutUpload
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\ImportResultSchema
     */
    public function importCourseWithoutUpload($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false', $dry_run = 'false')
    {
        list($response) = $this->importCourseWithoutUploadWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run);
        return $response;
    }

    /**
     * Operation importCourseWithoutUploadWithHttpInfo
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\ImportResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function importCourseWithoutUploadWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false', $dry_run = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
        $request = $this->importCourseWithoutUploadRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ImportResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importCourseWithoutUploadAsync
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseWithoutUploadAsync($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false', $dry_run = 'false')
    {
        return $this->importCourseWithoutUploadAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importCourseWithoutUploadAsyncWithHttpInfo
     *
     * Create a course
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importCourseWithoutUploadAsyncWithHttpInfo($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false', $dry_run = 'false')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
        $request = $this->importCourseWithoutUploadRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version, $dry_run);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importCourseWithoutUpload'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  \RusticiSoftware\Engine\V2\Model\ImportRequestSchema $import_request (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importCourseWithoutUploadRequest($engine_tenant_name, $course_id, $import_request, $may_create_new_version = 'false', $dry_run = 'false')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling importCourseWithoutUpload'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling importCourseWithoutUpload'
            );
        }
        // verify the required parameter 'import_request' is set
        if ($import_request === null || (is_array($import_request) && count($import_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import_request when calling importCourseWithoutUpload'
            );
        }

        $resourcePath = '/courses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($dry_run !== null) {
            $queryParams['dryRun'] = ObjectSerializer::toQueryValue($dry_run);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }


        // body params
        $_tempBody = null;
        if (isset($import_request)) {
            $_tempBody = $import_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseConfiguration
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseConfiguration($engine_tenant_name, $course_id, $configuration_settings)
    {
        $this->setCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings);
    }

    /**
     * Operation setCourseConfigurationWithHttpInfo
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseConfigurationWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseConfigurationAsync
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsync($engine_tenant_name, $course_id, $configuration_settings)
    {
        return $this->setCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for this course.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseConfigurationRequest($engine_tenant_name, $course_id, $configuration_settings)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setCourseConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseTitle
     *
     * Sets the course title for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title title (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseTitle($engine_tenant_name, $course_id, $title)
    {
        $this->setCourseTitleWithHttpInfo($engine_tenant_name, $course_id, $title);
    }

    /**
     * Operation setCourseTitleWithHttpInfo
     *
     * Sets the course title for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseTitleWithHttpInfo($engine_tenant_name, $course_id, $title)
    {
        $returnType = '';
        $request = $this->setCourseTitleRequest($engine_tenant_name, $course_id, $title);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseTitleAsync
     *
     * Sets the course title for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsync($engine_tenant_name, $course_id, $title)
    {
        return $this->setCourseTitleAsyncWithHttpInfo($engine_tenant_name, $course_id, $title)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseTitleAsyncWithHttpInfo
     *
     * Sets the course title for `courseId`
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseTitleAsyncWithHttpInfo($engine_tenant_name, $course_id, $title)
    {
        $returnType = '';
        $request = $this->setCourseTitleRequest($engine_tenant_name, $course_id, $title);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseTitle'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  \RusticiSoftware\Engine\V2\Model\TitleSchema $title (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseTitleRequest($engine_tenant_name, $course_id, $title)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setCourseTitle'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseTitle'
            );
        }
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling setCourseTitle'
            );
        }

        $resourcePath = '/courses/{courseId}/title';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($title)) {
            $_tempBody = $title;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCourseVersionConfiguration
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setCourseVersionConfiguration($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        $this->setCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings);
    }

    /**
     * Operation setCourseVersionConfigurationWithHttpInfo
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCourseVersionConfigurationWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $configuration_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setCourseVersionConfigurationAsync
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsync($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        return $this->setCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCourseVersionConfigurationAsyncWithHttpInfo
     *
     * Set configuration settings for this course and version.
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCourseVersionConfigurationAsyncWithHttpInfo($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        $returnType = '';
        $request = $this->setCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $configuration_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCourseVersionConfiguration'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id (required)
     * @param  int $version_id the course version (required)
     * @param  \RusticiSoftware\Engine\V2\Model\SettingsPostSchema $configuration_settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setCourseVersionConfigurationRequest($engine_tenant_name, $course_id, $version_id, $configuration_settings)
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling setCourseVersionConfiguration'
            );
        }
        // verify the required parameter 'configuration_settings' is set
        if ($configuration_settings === null || (is_array($configuration_settings) && count($configuration_settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configuration_settings when calling setCourseVersionConfiguration'
            );
        }

        $resourcePath = '/courses/{courseId}/versions/{versionId}/configuration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }

        // path params
        if ($course_id !== null) {
            $resourcePath = str_replace(
                '{' . 'courseId' . '}',
                ObjectSerializer::toPathValue($course_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'versionId' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($configuration_settings)) {
            $_tempBody = $configuration_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadAndImportCourse
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \RusticiSoftware\Engine\V2\Model\ImportResultSchema
     */
    public function uploadAndImportCourse($engine_tenant_name, $course_id, $may_create_new_version = 'false', $dry_run = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        list($response) = $this->uploadAndImportCourseWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $file, $uploaded_content_type);
        return $response;
    }

    /**
     * Operation uploadAndImportCourseWithHttpInfo
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \RusticiSoftware\Engine\V2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \RusticiSoftware\Engine\V2\Model\ImportResultSchema, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadAndImportCourseWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = 'false', $dry_run = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
        $request = $this->uploadAndImportCourseRequest($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $file, $uploaded_content_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\ImportResultSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\RusticiSoftware\Engine\V2\Model\MessageSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadAndImportCourseAsync
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAndImportCourseAsync($engine_tenant_name, $course_id, $may_create_new_version = 'false', $dry_run = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        return $this->uploadAndImportCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $file, $uploaded_content_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAndImportCourseAsyncWithHttpInfo
     *
     * Upload a course to import
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAndImportCourseAsyncWithHttpInfo($engine_tenant_name, $course_id, $may_create_new_version = 'false', $dry_run = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        $returnType = '\RusticiSoftware\Engine\V2\Model\ImportResultSchema';
        $request = $this->uploadAndImportCourseRequest($engine_tenant_name, $course_id, $may_create_new_version, $dry_run, $file, $uploaded_content_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadAndImportCourse'
     *
     * @param  string $engine_tenant_name tenant for this request (required)
     * @param  string $course_id A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
     * @param  bool $may_create_new_version Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn&#39;t already exist. (optional, default to false)
     * @param  bool $dry_run Validate the course can be imported (mainly by validating the manifest), but don&#39;t actually import it. (optional, default to false)
     * @param  \SplFileObject $file The course content file to import. (optional)
     * @param  string $uploaded_content_type The MIME type identifier for the content to be uploaded (optional, default to application/zip)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadAndImportCourseRequest($engine_tenant_name, $course_id, $may_create_new_version = 'false', $dry_run = 'false', $file = null, $uploaded_content_type = 'application/zip')
    {
        // verify the required parameter 'engine_tenant_name' is set
        if ($engine_tenant_name === null || (is_array($engine_tenant_name) && count($engine_tenant_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_tenant_name when calling uploadAndImportCourse'
            );
        }
        // verify the required parameter 'course_id' is set
        if ($course_id === null || (is_array($course_id) && count($course_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $course_id when calling uploadAndImportCourse'
            );
        }

        $resourcePath = '/courses/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($course_id !== null) {
            $queryParams['courseId'] = ObjectSerializer::toQueryValue($course_id);
        }
        // query params
        if ($may_create_new_version !== null) {
            $queryParams['mayCreateNewVersion'] = ObjectSerializer::toQueryValue($may_create_new_version);
        }
        // query params
        if ($dry_run !== null) {
            $queryParams['dryRun'] = ObjectSerializer::toQueryValue($dry_run);
        }
        // header params
        if ($engine_tenant_name !== null) {
            $headerParams['engineTenantName'] = ObjectSerializer::toHeaderValue($engine_tenant_name);
        }
        // header params
        if ($uploaded_content_type !== null) {
            $headerParams['uploadedContentType'] = ObjectSerializer::toHeaderValue($uploaded_content_type);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
